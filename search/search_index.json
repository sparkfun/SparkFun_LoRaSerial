{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>Out of the box, the SparkFun LoRaSerial products are simple-to-use point-to-point serial radio pair and can be used with little or no configuration. This Product Manual provides detailed descriptions of all the available features of the LoRaSerial products.</p> <p>The line of LoRaSerial products offered by SparkFun all run identical firmware. The LoRaSerial repo and this guide cover the following products:</p> SparkFun LoRaSerial Kit - 915MHz (WRL-19311) SparkFun LoRaSerial Enclosed Kit - 915MHz (WRL-20029) <p>If you have an issue, feature request, bug report, or a general question about the LoRaSerial firmware specifically we encourage you to post your comments on the firmware's repository.</p>"},{"location":"at_commands/","title":"AT Commands","text":"<p>LoRaSerial radios are very flexible. By default, the radio is looking for serial communication at 57600bps. Open the terminal of your choice and enter +++ and wait for an OK. The radio is now ready for an AT command.</p> <p>A PDF of all AT commands is available here.</p> <p>Below is a brief list of commands:</p> AT Command Command Description +++ Enter command mode AT Reports OK AT? Display help text ATB Break the link ATD Display the debug settings ATF Restore factory settings ATG Generate new netID and encryption key ATI Display the radio version ATI? Display the information commands ATIn Display system information ATO Exit command mode ATP Display probe trigger settings ATR Display radio settings ATS Display the serial settings ATT Enter training mode ATW Save current settings to NVM ATZ Reboot the radio AT-Param=xxx Set parameter's value to xxx by name (Param) AT-Param? Print parameter's current value by name (Param) AT-? Display the setting values <p>Table of AT Commands</p> <p>The commands are best discussed in groups:</p> <ul> <li>Radio Commands</li> <li>Serial Commands</li> <li>Info Commands</li> <li>Debug Commands</li> </ul> <p>A parameter is set using the AT- prefix, followed by the name of the command with an equals sign and the value to set. For example, sending AT-Echo=1** will enable serial echo. This setting can be stored in NVM (non-volatile memory) by sending the ATW command. To query a setting, send the AT command without a value and the device will respond with the current value. For example, sending AT-FrequencyMax will generate the response 928.000 followed by OK.</p>"},{"location":"at_commands/#radio-commands","title":"Radio Commands","text":"<p>Table of common radio link parameters</p> <p>A table of the subset of the common Radio Link Parameters is available here in PDF format.</p> <p>Note: Some settings must be identical on both radios for the link to be possible. These settings are used to generate the unique hop table. If settings are not compatible between radios, they will not be able to communicate.</p> AT Command Command Description AT-AirSpeed Data rate over the air. Overrides bandwidth, spread, and coding. AT-AutoTune Adjust frequency based on received frequency offset AT-Bandwidth Low number is longer range, less data rate AT-ClientFindPartnerRetryInterval Seconds before FIND_PARTNER xmit during training AT-CodingRate Set LoRa link coding rate denominator AT-DataScrambling Apply IBM Data Whitening to reduce DC bias AT-EnableCRC16 Include 16-bit CRC with each packet AT-EncryptData Use AES-128-GCM for each packet AT-EncryptionKey 16 byte key used for AES encryption AT-FramesToYield Pause transmission for X frames to allow 2-way traffic AT-FrequencyHop Enable frequency hopping spread spectrum AT-FrequencyMax Maximum allowed radio frequency AT-FrequencyMin Minimum allowed radio frequency AT-HeartBeatTimeout ms wait before sending link ping AT-MaxDwellTime Amount of time before hopping AT-MaxResends Attempts before dropping packet AT-NetID Network ID AT-NumberOfChannels Divide available spectrum by this amount AT-OperatingMode Multipoint or P2P AT-OverHeadtime Additional ms before ACK timeout occurs AT-PreambleLength Set LoRa preamble length AT-SelectLedUse Define LED behavior AT-Server Synchronize network clock AT-SpreadFactor High number is longer range, less data rate AT-SyncWord Set LoRa sync word AT-TrainingKey 16 byte AES key used during training AT-TrainingTimeout Minutes before training mode exits AT-TxPower Transmit power in dBm AT-TxToRxUsec \u03bcs between when TX sends and RX gets packet AT-VerifyRxNetID Validate packets against the NetID <p>Table of Radio Commands</p> <ul> <li> <p>AirSpeed - This is the effective rate in bits-per-second at which data is sent over the air. In general, the lower the airspeed, the greater the transmission distance. LoRaSerial uses buffers to receive and send serial over USB or UART at the SerialSpeed and begins sending that data in chunks over the air at the AirSpeed. The AirSpeed setting does not have to match the SerialSpeed. It is recommended to limit the total incoming data to match the airspeed. For example, regularly sending a group of 300 bytes with an air speed of 4800 bps (480 bytes per second) will allow the radio sufficient bandwidth. Sending 1,000 bytes per second with an air speed of 4800 bps (480 bytes per second) will within a few seconds overwhelm the link leading to buffer overflow and data loss. The default is 4800bps. Allowed values are 400, 1200, 2400, 4800, 9600, and 19200 bits per second. Changing the AirSpeed value overwrites the following 5 parameters:</p> </li> <li> <p>HeartbeatTimeout</p> </li> <li>RadioBandwidth</li> <li>RadioCodingRate</li> <li>RadioSpreadFactor</li> <li>TxToRxUsec</li> </ul> <p>After AirSpeed is set, it is possible to modify any of the above five parameters. Note that AirSpeed is just an easy way to set the five parameters to known values. AirSpeed is not a parameter that is transmitted during training, merely a convenient way to set the five parameters in one step.</p> <p>Note: The AirSpeed setting can be queried, but it is not back calculated. Said differently, after a system reset, the AirSpeed setting will report 0. This is because calculating the equivalent airspeed based on the user's settings results in non-sensical values that do not map cleanly with the defined AirSpeed options. Currently, the way to verify the device is set to the correct airspeed is to check the 5 parameters shown above against the settings shown on the AirSpeed calculation page.</p> <ul> <li> <p>AutoTune - Enabling autotune will cause the radio to tune the receiver frequency based on the calculated frequency error. This is used for testing and is not recommended for general use.</p> </li> <li> <p>Bandwidth - The bandwidth used around a given frequency during LoRa transmissions. This setting is in kHz. This setting is overwritten if the AirSpeed setting is changed. It is recommended to use the airspeed setting unless you are very aware of the consequences. In general, a lower bandwidth number provides a longer range, but a lower overall data rate. Allowed bandwidths: 10.4, 15.6, 20.8, 31.25, 41.7, 62.5, 125.0, 250.0, and 500.0kHz.</p> </li> <li> <p>ClientFindPartnerRetryInterval - In training mode, the client will transmit a special packet and then await a response from a server. This is the number of seconds between re-transmits of the FIND_PARTNER packet.</p> </li> <li> <p>CodingRate - The coding rate used during LoRa transmissions. It is recommended to use the airspeed setting unless you are very aware of the consequences. This setting is overwritten if the AirSpeed setting is changed. In general, a higher spread factor provides a longer range, but a lower overall data rate. Allowed spread factors: 6 to 12 (inclusive).</p> </li> <li> <p>DataScrambling - Enabling data scrambling will send all packets through an IBM data whitening process. This removes long sets of 1s or 0s from the packet to reduce DC bias during transmission. This is generally not needed and is not recommended when AES encryption is enabled. By default, scrambling is turned off.</p> </li> <li> <p>EnableCRC16 - When CRC is enabled, any packet that does not have a valid CRC will be ignored. The SX1276 IC has CRC at the radio interface, but because of RF noise, the number of corrupt packets is noticeable. This extra layer ensures packet delivery. Enabling CRC will add two bytes to each frame.</p> </li> <li> <p>EncryptData - By default, all packets are encrypted using 128-bit AES GCM. Disabling this will not achieve a greater range or bandwidth. Disabling encryption will allow all packets to be seen in clear text via an SDR or other monitoring device.</p> </li> <li> <p>EncryptionKey - This is the 16-byte key used for AES encryption. While SparkFun provides a default value, it is strongly recommended to change this value for your own networks. This can be changed via command or via the P2P training method. Please see P2P Training for more information.</p> </li> <li> <p>FramesToYield - During large data flows the receiving radio can request a yield within the ACK packet. When the transmitter receives a yield request, data flow is paused for FramesToYield * Frame Transmit Time. This gives the receiver a chance to transmit its own data allowing data to flow in both directions on the link.</p> </li> <li> <p>FrequencyHop - The LoRaSerial implements frequency hopping spread spectrum (FHSS) by default to meet FCC Part 15.247 compliance. Turning off frequency hopping is not recommended unless You Know What You\u2019re Doing\u2122.</p> </li> <li> <p>FrequencyMin/FrequencyMax - These are the lower and upper bounds for the allowed transmission frequencies in megahertz. By default, this is 902.0 to 928.0.</p> </li> <li> <p>HeartbeatTimeout - Heartbeats are transmitted on a regular basis by the server and in point-to-point mode by the clients. This parameter specifies the time in milliseconds during which a HEARTBEAT frame should be transmitted. If a HEARTBEAT frame is not received within three (3) times this interval then the point-to-point link is broken. The default heartbeatTimeout is 5000 milliseconds (5 seconds).</p> </li> <li> <p>MaxDwellTime - The number of milliseconds of transmission allowed on a given frequency before hopping intra-packet. The default is 400ms to be compliant with FCC Part 15.247. This means the radio will change its frequency to the next channel in the hop table during the packet transmission. Note this is the maximum dwell time; depending on the air speed setting the radio may have a hopping period that is shorter than the dwell time.</p> </li> <li> <p>MaxResends - Number of retransmission attempts when an ACK is not received from the destination radio. The valid range is 0 to 255. The default of zero represents infinite and retries will continue as long as the two radios are receiving HEARTBEAT frames from each other. The transmission will fail only when the link breaks due to not receiving HEARTBEAT frames.</p> </li> <li> <p>NetID - When VerifyRxNetID is enabled, each received packet is checked against the radio's network ID. If a packet is received with a non-matching NetID it is discarded. Changing the NetID is a handy way to make sure your radios do not interfere with other radios in the same vicinity.</p> </li> <li> <p>NumberOfChannels - The available spectrum (default is 902MHz to 928MHz) is divided by this number of channels to create the channel spacing and allowed frequency list (aka the \u2018hop table\u2019). The default is 50 channels to meet FCC Part 15.247 compliance and may be changed to meet local regulations.</p> </li> <li> <p>OperatingMode - The radios can operate in one of two different modes: Multipoint and Point-To-Point. See Operating Modes for more information.</p> </li> <li> <p>MODE_MULTIPOINT (0) - A single server with multiple clients. All radios may broadcast to all other radios, but data is not guaranteed to be received by the other radios. This mode is great when real-time transmission is necessary and the application can tolerate some loss of data.</p> </li> <li> <p>MODE_POINT_TO_POINT (1, default) - Communications between two LoRaSerial radios with guaranteed delivery of frames or the link breaks.</p> </li> <li> <p>OverheadTime - The number of milliseconds to add to ACK and datagram times before ACK timeout occurs. The default is 10 milliseconds.</p> </li> <li> <p>PreambleLength - The number of sync words to send at the start of a packet. Note that two LoRa radios with the same settings but different preamble lengths have been shown to intermittently receive packets from each other. Therefore, using a unique preamble length does not guarantee exclusivity. Allowed values: 6 to 65535.</p> </li> <li> <p>SelectLedUse - Select how to display information on the LEDs. See LED States for more information.</p> </li> <li> <p>Server - Enable (1) or disable (0) the server mode for training and for multipoint operation. The default is client mode (0). The radio designated as Server synchronizes the network. A server is required for Multipoint and Training modes.</p> </li> <li> <p>SpreadFactor - The spread factor used during LoRa transmissions. It is recommended to use the airspeed setting unless you are very aware of the consequences. This setting is overwritten if the AirSpeed setting is changed. In general, a higher spread factor provides a longer range, but a lower overall data rate. Allowed spread factors: 6 to 12 (inclusive).</p> </li> <li> <p>SyncWord - The byte used to synchronize LoRa transmissions. In general, this is set to 0x12 for non-LoRaWAN networks. Note that two LoRa radios with the same settings but different sync words have been shown to intermittently receive packets from each other. Therefore, using a unique synch word does not guarantee exclusivity. Allowed values: 0 to 255.</p> </li> <li> <p>TxPower - The LoRaSerial uses a high-power 1W transceiver. By default, all transmissions are sent at the highest possible power of 30dBm which is compliant with FCC Part 15.247 when used with an antenna that has a gain of 6dBi or less. If your local regulations require lower transmission power this setting can be lowered. Allowed values are 30 down to 14dBm. Note: The chosen setting is the actual measured transmit power at the SMA connector. An internal lookup table sets the radio settings accordingly.</p> </li> <li> <p>TxToRxUsec - This is the number of microseconds between when the transmitter completes a transmission, and when the receiver completes the reception of that packet. For lower airspeeds, this value increases and generally tracks to 1 symbol time. It is recommended to use the airspeed setting unless you are very aware of the consequences. This setting is overwritten if the AirSpeed setting is changed.</p> </li> <li> <p>VerifyRxNetID - Enable (1) or disable (0) the verification of the netID value during reception. The default is enabled (1).</p> </li> </ul>"},{"location":"at_commands/#serial-commands","title":"Serial Commands","text":"AT Command Command Description AT-CopySerial Copy the serial parameters to the training client AT-Echo Print locally inputted serial AT-FlowControl Enable the use of CTS/RTS flow control signals AT-InvertCts Invert the input of CTS AT-InvertRts Invert the output of RTS AT-SerialDelay ms of no data before fractional buffer is sent AT-SerialSpeed Hardware UART baud rate AT-UsbSerialWait Wait for USB enumeration before radio start <ul> <li> <p>CopySerial - False by default. Set to true to transmit Serial settings during training from Server to Clients.</p> </li> <li> <p>Echo - By default, the radio will not echo the incoming serial. This is helpful at times if a user is typing data directly into a terminal. During AT configuration echo is turned on regardless of this setting.</p> </li> </ul> <p></p> <ul> <li> <p>FlowControl - If flow control is enabled, LoRaSerial will send data when its CTS pin is driven low (the host system is telling the radio to transmit). If flow control is enabled, LoRaSerial will drive its RTS low if its serial buffer is full (the radio is telling the host system to hold its horses). CTS and RTS pins are only exposed on the UART connector but if flow control is enabled, the UART flow control pins will apply to both USB and serial data streams. Internal pull-ups are used so if flow control is enabled, RTS and CTS must not be left floating. By default, flow control is turned off.</p> </li> <li> <p>InvertCts - By default, InvertCts is false and CTS is high when data is allowed to flow. Enable InvertCts to do the opposite.</p> </li> <li> <p>InvertRts - By default, InvertRts is false and RTS is high when data is allowed to flow. Enable InvertRts to do the opposite.</p> </li> <li> <p>SerialDelay - The number of milliseconds of timeout before a partial packet is sent. For example, if a partial frame of 12 bytes is received, the radio will wait this amount for more bytes before initiating a transmission. The default is 50ms. Allowed values: 10 to 2000ms.</p> </li> <li> <p>SerialSpeed - Controls the baud rate in bits-per-second used over the UART connector. Data sent over USB will be sent/received regardless of this setting. The default is 57600bps. Allowed values are 2400, 4800, 9600, 14400, 19200, 38400, 57600, and 115200bps.</p> </li> <li> <p>UsbSerialWait - If enabled, the radio will wait for the USB port to be enumerated and open before beginning operation. The default is false.</p> </li> </ul>"},{"location":"at_commands/#info-commands","title":"Info Commands","text":"AT Command Command Description ATI0 Show user settable parameters ATI1 Show board variant ATI2 Show firmware version ATI3 Display RSSI value ATI4 Get random byte from RSSI ATI5 Show max possible bytes per second ATI6 Display current radio state ATI7 Show current FHSS channel ATI8 Display system unique ID ATI9 Display the maximum datagram size ATI10 Display radio metrics ATI13 Display the SX1276 registers ATI14 Dump the radioTxBuffer <ul> <li> <p>ATI0 - List all available AT commands.</p> </li> <li> <p>ATI1 - Shows the board variant. For example \"SparkFun LoRaSerial SAMD21 1W 915MHz\".</p> </li> <li> <p>ATI2 - Shows the LoRaSerial firmware version. For example \"2.0\".</p> </li> <li> <p>ATI3 - Shows the last RSSI during a successful reception. For example \"-76\".</p> </li> <li> <p>ATI4 - Queries the radio for a random byte, 0 to 255, based on RF noise. For example \"42\".</p> </li> <li> <p>ATI5 - Based on settings, returns the ideal number of bytes capable of being transmitted over the link. This number assumes no retransmits and should be used only as a guide to set expectations of the host system.</p> </li> <li> <p>ATI6 - Displays the current radio state. For example: \"State: P2P: Receiving Standby LinkUptime:     2:45:08\".</p> </li> <li> <p>ATI7 - Displays the current channel number. For example: \"29\".</p> </li> <li> <p>ATI8 - Displays the unique 32-character, 16-byte, 128-bit value marked into the SAMD21 microcontroller. For example: \"5BCEDAE13630595020312E32102317FF\".</p> </li> <li> <p>ATI9 - Displays the maximum number of bytes that can be transmitted. Different radio settings will use fewer or a greater number of bytes for overhead. For example: \"249\".</p> </li> <li> <p>ATI10 - Displays a large number of metrics related to the radio link including datagrams sent, link uptime, ACK counts, buffer states, etc.</p> </li> <li> <p>ATI13 - Displays the contents of all the registers in the SX1276 LoRa transceiver.</p> </li> <li> <p>ATI14 - Displays the contents of the current transmit buffer.</p> </li> </ul>"},{"location":"at_commands/#remote-training","title":"Remote Training","text":"<p>Currently, only one remote command is supported - RTT. Issuing this command to the local radio when the link is up will cause the remote radio to drop from the link and enter training mode. The remote radio will wait in this mode until training is completed, a local ATZ command is entered into the remote device, or the Train button is pressed on the remote device.</p> <p>This command is generally used to remotely configure a radio. First, the RTT command is issued, the local radio is configured (including enabling Server), then the ATT is issued to push the local radio into training. Because the local radio is the server, its settings are set to the remote radio. The remote radio will reset and start with these newly issued settings. The local radio needs to reset with an ATZ command and the link should be re-established with new settings. Below is a command script to achieve this remote configuration. We assume the radios are currently linked at the start of the script.</p> <p>Note: RTT is only supported in P2P mode.</p> <pre><code>+++\nRTT\nAT-Server=1\nAT-AirSpeed=9600\nATW\nATT\n(Wait for the 'Client XYZ Trained' message)\nATZ\n</code></pre>"},{"location":"firmware_build/","title":"Building LoRaSerial Firmware","text":"<p>The open source LoRaSerial firmware builds under Windows and Linux.  Use the following procedures to setup the environment and perform the build:</p> <ul> <li>Windows</li> <li>Linux</li> </ul>"},{"location":"firmware_build/#ubuntu-build-environment","title":"Ubuntu Build Environment","text":"<p>The following setup and build instructions were tested on Ubuntu 22.04.1. The build can run on a physical or virtual CPU. The following section describes how to setup a virtual machine. Further sections describe the build environment and how to perform the build.</p>"},{"location":"firmware_build/#virtual-machine","title":"Virtual Machine","text":"<p>Execute the following commands in the VirualBox application to create a virtual machine:</p> <ol> <li>Click on the Machine menu item</li> <li>Click on the New submenu item</li> <li>Specify the machine Name, e.g.: Sparkfun_LoRaSerial_22.04.1</li> <li>Select Type, e.g.: Linux</li> <li>Select Version, e.g.: Ubuntu (64-bit)</li> <li>Click the Next&gt; button</li> <li>Select the memory size: 7168</li> <li>Click the Next&gt; button</li> <li>Click on Create a virtual hard disk now</li> <li>Click the Create button</li> <li>Select VDI (VirtualBox Disk Image)</li> <li>Click the Next&gt; button</li> <li>Select Dynamically allocated</li> <li>Click the Next&gt; button</li> <li>Select the disk size: 128 GB</li> <li>Click the Create button</li> <li>Click on the Settings button</li> <li>Click on Storage</li> <li>Click the empty CD icon</li> <li>On the right-hand side, click the CD icon</li> <li> <p>Click on Choose a disk file... An operating system is needed for the virtual machine to enable it to run applications.  Download one of the following operating system images (.iso files):</p> </li> <li> <p>Ubuntu Desktop (Linux)</p> </li> <li> <p>Windows</p> </li> <li> <p>Choose one of the .iso files downloaded above</p> </li> <li>Click the Open button</li> <li>Click on Network</li> <li>Under 'Attached to:' select Bridged Adapter</li> <li>Click the OK button</li> <li>Click the Start button</li> <li>Install the operating system</li> <li> <p>Log into the operating system</p> </li> <li> <p>For Ubuntu:</p> <ol> <li>Click on Activities</li> <li>Type terminal into the search box</li> <li> <p>In the terminal window     a. sudo apt install -y net-tools openssh-server     b. ifconfig</p> <p>Write down the IP address</p> </li> <li> <p>On the PC (Linux) in a terminal window     a. ssh-keygen -t rsa -f ~/.ssh/SparkFun_LoRaSerial_22.04.1     b. ssh-copy-id -o IdentitiesOnly=yes -i ~/.ssh/SparkFun_LoRaSerial_22.04.1  &lt;username&gt;@&lt;IP address&gt;     c. ssh -Y &lt;username&gt;@&lt;IP address&gt;</p> </li> </ol> </li> </ol> <p>Execute the following commands to create the build environment for the SparkFun LoRaSerial Firmware:</p> <ol> <li>sudo adduser $USER dialout</li> <li>sudo shutdown -r 0</li> </ol> <p>Reboot to ensure that the dialout privilege is available to the user</p> <ol> <li>sudo apt update</li> <li>sudo apt install -y  git  gitk  git-cola  minicom  python3-pip</li> <li>sudo pip3 install pyserial</li> <li>mkdir ~/SparkFun</li> <li>cd ~/SparkFun</li> <li>nano serial-57600.sh</li> </ol> <p>Insert the following text into the file:</p> <pre><code>#!/bin/bash\n#   serial-57600.sh\n#\n#   Shell script to read the serial data from the LoRaSerial USB port\n#\n#   Parameters:\n#       1:  ttyACMn\n#\nsudo minicom -b 57600 -8 -D /dev/$1 &lt; /dev/tty\n</code></pre> <ol> <li>chmod +x serial-57600.sh</li> </ol> <p>Get the SparkFun LoRaSerial Firmware sources</p> <ol> <li>mkdir ~/SparkFun/LoRaSerial</li> <li>cd ~/SparkFun/LoRaSerial</li> <li>git clone https://github.com/sparkfun/SparkFun_LoRaSerial .</li> </ol> <p>Install the Arduino IDE</p> <ol> <li>mkdir ~/SparkFun/arduino</li> <li>cd ~/SparkFun/arduino</li> <li>wget https://downloads.arduino.cc/arduino-1.8.15-linux64.tar.xz</li> <li>tar -xvf ./arduino-1.8.15-linux64.tar.xz</li> <li>cd arduino-1.8.15/</li> <li>sudo ./install.sh</li> <li>arduino</li> </ol>"},{"location":"firmware_build/#setup-the-arduino-build-environment","title":"Setup the Arduino Build Environment","text":"<p>Install the ARM Cortex-M0+ tools.  See SAMD21 MiniDev Hookup Guide for more documentation.</p> <ol> <li>Click on Tools in the menu bar</li> <li>Click on Board</li> <li>Click on Board Manager ...</li> <li>Scroll down to Arduino SAMD Boards (32-bits ARM Cortex-M0+)</li> <li>Click on Arduino SAMD Boards (32-bits ARM Cortex-M0+)</li> <li>Select version 1.8.13</li> <li>Click on the install button</li> <li>Click on the close button</li> </ol>"},{"location":"firmware_build/#install-the-sparkfun-board-packages","title":"Install the SparkFun Board Packages","text":"<ol> <li>Click on File in the menu bar</li> <li>Click on Preferences</li> <li>Go down to the Additional Boards Manager URLs text box</li> <li>Only if the textbox already has a value, go to the end of the value or values and add a comma</li> <li>Add the link: https://raw.githubusercontent.com/sparkfun/Arduino_Boards/main/IDE_Board_Manager/package_sparkfun_index.json</li> <li>Note the value in Sketchbook location</li> <li>Click the OK button</li> <li>Click on Tools in the menu bar</li> <li>Click on Board</li> <li>Click on Board Manager ...</li> <li>Scroll down and click on SparkFun SAMD Boards (dependency: Arduino SAMD Boards 1.8.1)</li> <li>Select version 1.8.9</li> <li>Click on the install button</li> <li>Click on the close button</li> <li>Click on Tools in the menu bar</li> <li>Click on Board</li> <li>Click on SparkFun SAMD (32-bits ARM Cortex-M0+) Boards</li> <li>Click on SparkFun LoRaSerial</li> </ol>"},{"location":"firmware_build/#install-the-required-libraries","title":"Install the required libraries","text":"<p>The following procedure installs the libraries needed to successfully build the LoRaSerial firmware.</p> <ol> <li>Click on Tools in the menu bar</li> <li>Click on Manage Libraries...</li> <li> <p>For each library:</p> <p>a. Enter the library name into the search box b. Scroll down the list if necessary to locate the specified libray c. Click on the library d. Select the specified version e. Click on the install button</p> </li> <li> <p>Install the following libraries:</p> <p>a. Crypto, v0.4.0 a. FlashStorage_SAMD, v1.3.2 a. JC_Button, v2.1.2 a. RadioLib, v5.1.2 a. SAMD_TimerInterrupt, v1.9.0</p> </li> <li> <p>Click on File in the menu bar</p> </li> <li>Click on Quit</li> </ol>"},{"location":"firmware_build/#external-libraries","title":"External Libraries","text":"<p>The WDT library is not registered with the Arduino IDE.  It must be added outside of the Arduino IDE environment.  Install the external libraries adding them to the Sketchbook location noted above.</p> <ol> <li>cd ~/Arduino/libraries</li> <li>mkdir WDTZero</li> <li>cd WDTZero/</li> <li>git clone https://github.com/javos65/WDTZero.git .</li> </ol>"},{"location":"firmware_build/#build-the-loraserial-firmware","title":"Build the LoRaSerial Firmware","text":"<p>Use the following procedure to get the project ready to build</p> <ol> <li>arduino</li> <li>Click on File in the menu bar</li> <li>Click on Open</li> <li>Select the project file: ~/SparkFun/LoRaSerial/Firmware/LoRaSerial/LoRaSerial.ino</li> <li>Click on the Open button</li> <li>Click on Tools in the menu bar</li> <li>Verify that Board lists \"SparkFun LoRaSerial\"</li> </ol>"},{"location":"firmware_build/#connect-the-loraserial-device","title":"Connect the LoRaSerial Device","text":"<ol> <li>Plug the LoRaSerial device into a USB port on the PC</li> <li>In the arduino program, click on Tools</li> <li>Click on Ports</li> <li>Select the port for the LoRaSerial device</li> </ol>"},{"location":"firmware_build/#compile","title":"Compile","text":"<ol> <li>Click on Sketch in the menu bar</li> <li>Click on Verify/Compile</li> <li>Using an editor or the Arduino IDE ake any source file changes until the Sketch (program) compiles cleanly</li> </ol>"},{"location":"firmware_build/#upload-the-firmware","title":"Upload the Firmware","text":"<ol> <li>Click on Sketch</li> <li>Click on Upload</li> </ol>"},{"location":"firmware_build/#arduino-cli","title":"Arduino CLI","text":"<p>The firmware can be compiled using Arduino CLI. This makes compilation fairly platform independent and flexible. All release candidates and firmware releases are compiled using Arduino CLI using a github action. You can see the source of the action here, and use it as a starting point for Arduino CLI compilation.</p>"},{"location":"firmware_update/","title":"Updating LoRaSerial Firmware","text":"<p>From time to time SparkFun will release new firmware for the LoRaSerial product line to add and improve functionality. Firmware can be upgraded using the SparkFun BOSSA GUI.</p>"},{"location":"firmware_update/#bossa-gui","title":"BOSSA GUI","text":"<p>The LoRaSerial utilizes a SAMD21 microcontroller. To update the firmware, obtain the SparkFun BOSSA GUI from this repo. The GUI is PyQt5 based on the Python SAM-BA Loader script that can be run from the command line. Alternatively, Windows, macOS and Linux-compatible executables are available in the release section. There is a Python package too, which works nicely on Raspberry Pi.</p> <p>Next, get the latest LoRaSerial Firmware binary located in LoRaSerial Binaries folder. Note: There are two types of firmware files, one 'with_bootloader' and one without. You can ignore the 'with_bootloader' type file.</p> <p>Run the GUI.</p> <p>Click <code>Browse</code> and select the firmware file.</p> <p>Click the <code>COM Port</code> dialog box and select the correct port. On macOS, you will see two ports - select the one called <code>tty.usbmodem</code>.</p> <p>Click <code>Upload Binary</code> to start the upload.</p>"},{"location":"firmware_update/#bootloader-mode","title":"Bootloader Mode","text":"<p>The BOSSA GUI will attempt to put the SAMD21 into bootloader mode automatically to perform the update. But we have noticed that this fails occasionally on some machines - it is machine-dependent.</p> <p></p> <p>On those machines, you will need to put the SAMD21 into bootloader mode manually by opening the case and giving the reset button a double-tap.</p> <p></p> <p>Small Philips head screw</p> <p>Remove the two side screws and open the LoRaSerial enclosure to expose the reset button. </p> <p></p> <p>SAMD21 reset button</p> <p>Connect the LoRaSerial to the computer over USB. Double-tap the reset button to enter bootloader mode. You should see the blue LED slowly pulse on/off. Now open the BOSSA GUI, select the Binary file you downloaded, select the COM port of the LoRaSerial device. Uncheck the SAMD21 check-box and finally click <code>Upload Binary</code>.</p>"},{"location":"hardware_overview/","title":"Hardware Overview","text":"<p>The LoRaSerial is a SAMD21 based assembly with an SX1276 LoRa radio with innovative firmware to make things as simple as possible.</p> <p></p> <p>SAMD21 based serial radio</p> <p></p> <p>1-watt module containing the SX1276 and a power amplifier</p> <p>The LoRaSerial uses a 1W LoRa radio based on the SX1276 radio along with a SAMD21 utilizing the UF2 bootloader. Any serial received at USB or serial port will be queued up, encrypted, and sent out over the radio. Any received packets are checked for CRC and Network ID, decrypted, then printed on both USB and serial interfaces.</p> <p>Note: By default, there is a 50ms timeout in which the radio will wait for additional characters to be received until a partial frame is sent.</p>"},{"location":"hardware_overview/#usb-c","title":"USB C","text":"<p>USB C connector for power and serial</p> <p>The USB C connector provides power and serial communication to the unit. LoRaSerial will automatically show up on a computer or SBC (single board computer) as a serial COM port at a default of 57600bps. Currently, only 8-N-1 serial communication is supported but we are open to additional features as users' needs arise.</p>"},{"location":"hardware_overview/#6-pin-jst","title":"6-Pin JST","text":"<p>6-pin locking JST connector for power and  serial</p> <p>LoRaSerial features a \u2018locking\u2019 type 6-pin JST connector. The connector on LoRaSerial is X and mates with a connector JST-GHR-06V. Each LoRaSerial radio comes with a cable to connect from the JST connector to breadboard-friendly pins. If you need additional cables they are available here (Note: the wire color may be different between cables). </p> <p>The pinout is as follows:</p> <ul> <li>PWR - 3.3-5V</li> <li>RX - Receive (Input into LoRaSerial)</li> <li>TX - Transmit (Output from LoRaSerial)</li> <li>CTS - Clear To Send (Input into LoRaSerial)</li> <li>RTS - Ready To Send (Output from LoRaSerial)</li> <li>GND - Ground</li> </ul> <p>PWR (3.3-5V) - LoRaSerial requires 3.3 to 5V to operate. We recommend 5V for maximum transmission range but we\u2019ve found operating off of a LiPo at 3.7 to 4.2V works great.</p> <p>RX (Receive) - Connect this pin to the TX pin of your system. This pin is 3.3-5V tolerant and has an internal pull-up.</p> <p>TX (Transmit) - Connect this pin to the RX pin of your system. This pin uses 3.3V logic.</p> <p>CTS (Clear To Send) - (Optional) Connect this pin to a GPIO of your system. This pin is 3.3-5V tolerant and has an internal pull-up. When this pin is low LoRaSerial will continue to send data. If the host system pulls this pin high, the radio will stop sending data.</p> <p>RTS (Ready To Send) - (Optional) Connect this pin to a GPIO of your system. This pin uses 3.3V logic. If the radio\u2019s buffer (size currently is 4096 bytes) becomes full the system will drive RTS high indicating that it should not be passed more data. If more serial data is received, the buffer will be overwritten, oldest data first.</p> <p>GND (Ground) - Connect this pin to the ground of your system.</p>"},{"location":"hardware_overview/#flow-control","title":"Flow Control","text":"<p>If flow control is enabled, LoRaSerial will send data when its CTS pin is driven low (the host system is telling the radio to transmit). If flow control is enabled, LoRaSerial will drive its RTS low if its serial buffer is full (the radio is telling the host system to hold its horses). CTS and RTS pins are only exposed on the UART connector but if flow control is enabled, the UART flow control pins will apply to both USB and serial data streams. Internal pull-ups are used so if flow control is enabled, RTS and CTS must not be left floating. By default, flow control is turned off.</p> <p>Hardware flow control applies to both the UART connection and the USB connector but in slightly different ways. </p> <p>The USB connection uses a concept called backpressure. It is not affected by the FlowControl setting and cannot be disabled. If LoRaSerial is not able to read the incoming data fast enough, the USB driver will indicate to the host\u2019s operating system that the data has not been consumed. Depending on the application, data will either be paused or lost. </p> <p></p> <p>This is most obvious in applications such as STRSVR (from RTKLIB). If STRSVR sends more data to the LoRaSerial than it can consume, STRSVR will begin to buffer the data until it can be sent. This is problematic for time-sensitive data, such as RTCM, where data, being delivered successfully but delayed but multiple seconds, can cause problems with RTK. If RTCM data is multiple seconds old, an RTK Fix will go to RTK Float, then fail because current RTCM data is not being delivered to the far end of the radio link. The easiest way to fix the problem is to increase the AirSpeed of the link.</p>"},{"location":"hardware_overview/#rssi-leds","title":"RSSI LEDs","text":"<p>4 LEDs indicating signal strength</p> <p>Four LEDs indicate in real-time the received signal strength or RSSI. These LEDs are meant to show a qualitative level of receive strength. Don\u2019t worry if you\u2019ve got three LEDs rather than four. LoRa technology is capable of transmitting a long range in harsh RF conditions. As long as you\u2019ve got one LED, you will be able to send and receive data.</p>"},{"location":"hardware_overview/#rpsma-connector","title":"RPSMA Connector","text":"<p>Reverse polarized SMA antenna connector</p> <p>Attach a 915MHz RPSMA antenna to this port. Not sure which is SMA and which is RPSMA? Check out this RF Connector Guide. The LoRaSerial is also compatible with any large 915MHz antennas including fiberglass antennas. We recommend a good thick RG58 RPSMA extension from the radio to your antenna to minimize loss. Remember, we are transmitting at 1W so keep your cables and connectors to a minimum.</p> <p>Note: Be careful of antennas that have a gain higher than 6 dBi as this may violate the maximum effective isotropic radiated power (EIRP) for your area/country.</p>"},{"location":"hardware_overview/#qwiic-connector","title":"Qwiic Connector","text":"<p>Qwiic connector for I2C communication</p> <p>The Qwiic connector and I2C accessibility are not yet implemented.</p>"},{"location":"hardware_overview/#train-button","title":"Train Button","text":"<p>Button to enter train mode</p> <p>LoRa Serial uses a unique and very easy-to-use train feature. Each radio has a default Network ID and AES key programmed into it. Changing these keys is as easy as pressing a button! </p> <p>Using a ballpoint pen or other small pointed device, press and hold the Train button for 2 seconds, until you see the RSSI LEDs begin to blink. You can release the button. If the LEDs begin to cylon (bounce back and forth) the device has entered training \u2018wait\u2019 mode where it waits for another device to ping it.</p> <p>On the second radio, press and hold the Train button for 2 seconds, until you see the RSSI LEDs begin to blink. Release the button. The RSSI LEDs on both units will blink in unison indicating that the units are now trained to each other.</p> <p>For security reasons, the radios are both set to the lowest transmission power to minimize any eavesdropper from monitoring the transaction. While the \u2018new\u2019 keys are themselves encrypted, they are encrypted using a published AES key so one could theoretically back out the new AES keys if they are within ~30ft of the devices when the radios are being trained. If you\u2019re paranoid, train the radios with the antennas off, within a few inches of each other. If total security is a concern, or if the radios cannot be physically brought near one another, the AES keys and/or the network IDs can be set via software commands.</p>"},{"location":"hardware_overview/#internal-reset-button","title":"Internal Reset Button","text":"<p>SAMD21 reset button</p> <p>The firmware on the LoRaSerial can be upgraded from a computer without ever having to open the unit. In the rare case that the SAMD21 needs to be forced into bootloader mode the reset button should be quickly double-tapped. The unit will then enter bootloader mode and wait for new firmware or for a reset event (button is pressed or power is cycled).</p> <p>Please see Updating LoRaSerial Firmware for more information.</p>"},{"location":"hardware_overview/#gpio","title":"GPIO","text":"<p>GPIOs on SAMD21</p> <p>Two GPIOs capable of ADC are broken out for potential future use.</p>"},{"location":"hardware_overview/#ufl-connector","title":"U.FL Connector","text":"<p>Zero ohm jumper resistor and U.FL connector</p> <p>For advanced users, the 915/868MHz modules feature a U.FL connector. This can be helpful if you need to embed the radio in an enclosure and need an external bulkhead RP-SMA connector. To use the U.FL connection, desolder the 0402 0\u03a9 jumper and move it to the U.FL's RF path.</p>"},{"location":"hardware_overview/#power-selection","title":"Power Selection","text":"<p>LoRaSerial uses an onboard 'ideal' MOSFET to select the high voltage source between the USB connector and the VCC/GND of the UART connector. This allows dual power supplies to be applied without fear of back-feeding a higher voltage onto a lower voltage system.</p>"},{"location":"hardware_overview/#enclosure","title":"Enclosure","text":"<p>The enclosure is industrial 3D SLA printed with an effective IPX rating of IP52 (dust and waterdrop protected).</p> <p>The enclosure is secured with two screws on either side of the unit. The top cover can be removed to expose the inner assembly.</p> <p></p> <p>LoRaSerial Dimensional Drawing</p> <p>The enclosure includes mounting holes for wall or rack mounting.</p> <p></p> <p>Note: Leaving a LoRaSerial unit exposed to daylight outdoors or near a window will cause the cover to darken over a period of months. This will not affect the performance of the radio or the enclosure.</p>"},{"location":"hardware_overview/#power-usage","title":"Power Usage","text":"<p>The SX1276-based radio module is rated for 1 watt. The radio can be adjusted from 14dBm up to 30dBm (default). </p> <p>Note: The AT-TxPower command ranges from 14 to 30 in dBm. The radio uses an internal lookup table to map the correct power output (30dBm by default) to the associated power level for the power amplifier (20 in this case).</p> <p>The average standby current is approximately 60mA when TxPower of 30 is selected. The average current varies based on the selected output power because the units will periodically transmit Find Partner packets when the link is down and Heartbeat packets when the link is up, even if there is no data waiting to be transmitted. </p> <p></p> <p>During broadcast, the radio can use much more than 1W. Use a good 5V supply capable of outputting at least 1A at 5V. A USB 3.0 port is good. A USB 2.0 port will considerably limit the capabilities of the radio.</p> <p></p> <p>The above table shows power usage during 100% broadcast envelope usage. The actual current usage will be proportionally lower depending on the amount of data transmitted. For example, if only half of the airspeed is used (240 bytes out of a max of 480 at airspeed 4800) then the transmitter will only be on for 50% of the time at the stated power.</p> <p>The power meter and hardware setup limited the ability to get to the full 30dBm output. The above measurements should be used as a rule-of-thumb for power considerations.</p>"},{"location":"led_states/","title":"LED States","text":"<p>A variety of LEDs are visible on the LoRaSerial radio to give the user feedback about the state of the system.</p> <p></p> <p>LEDs on the LoRaSerial</p> <p>The following diagram shows the various LEDs on the LoRaSerial device:</p> <pre><code>    Antenna         Qwiic\n+---------------------------+\n|                           |\n|     G4   G3   G2   G1     |\n|                           |\n|                           |\n|                       Red |\n|                           |\n|                           |\n|            Blue    Yellow |\n|                           |\n+---------------------------+\n    USB            Serial\n</code></pre> <p>The red LED is the power indicator. G1 through G4 in the diagram above are all green LEDs.</p>"},{"location":"led_states/#radio-reset","title":"Radio Reset","text":"<p>When the device is first powered on or is reset, all LEDs will blink quickly three times indicating system reset.</p>"},{"location":"led_states/#training","title":"Training","text":"<p>During training, the green RSSI LEDs will cylon back and forth. One green LED is lit at a time and the lit LED moves from side to side.</p> <pre><code>G4    G3    G2    G1\n                   X\n             X\n       X\n X\n       X\n             X\n                   X\n             X\n      ...\n</code></pre> <p>The yellow LED will blink when radio traffic is received and the blue LED will blink when radio traffic is transmitted. Once training is complete, the radio will reset causing all LEDS to blink.</p>"},{"location":"led_states/#led-mode-leds_rssi","title":"LED Mode - LEDS_RSSI","text":"<p>This is the default mode. The RSSI LEDs will indicate the link's signal strength. The mode number is 4.</p> <p>The LED behavior may be changed by using the AT-SelectLedUse command and setting the value to one of the mode numbers described in the sections below. As an example, the following commands cause the LEDs to display different information about the radio's behavior.</p> <pre><code>+++\nAT-SelectLedUse=4\nATO\n</code></pre> <ul> <li>The RSSI LEDs indicate the signal strength of the last received packet:<ul> <li>-70 &lt; RSSI: All green LEDs lit (strong)</li> <li>-100 &lt; RSSI &lt;= -70: G3, G2, G1 LEDs lit, G4 off</li> <li>-120 &lt; RSSI &lt;= -100: G2, G1 LEDs lit, G4 and G3 off</li> <li>-150 &lt; RSSI &lt;= -120: G1 LED lit, all G4, G3 and G2 off (weak)</li> <li>RSSI &lt;= -150: &lt;= All green LEDs off</li> </ul> </li> <li>The blue TX LED indicates when serial data is received over the radio and sent to the host, either over USB or hardware serial.</li> <li>The yellow RX LED indicates when serial data is received from the host and sent over the radio.</li> </ul>"},{"location":"led_states/#led-mode-leds_multipoint","title":"LED Mode - LEDS_MULTIPOINT","text":"<p>This mode gives the user insight into when the link is hopping and when a heartbeat is transmitted/received. The mode number is 0.</p> <pre><code>+++\nAT-SelectLedUse=0\nATO\n</code></pre> <ul> <li>The G4 LED pulses when the radio transmits a frame.</li> <li>The G3 LED is pulse width modulated to indicate the last received RSSI level.</li> <li>The G2 LED turns on when the link is up (data can pass).</li> <li>The G1 LED pulses when the radio successfully receives a frame.</li> <li>The blue LED pulses on the server radio when the server transmits a HEARTBEAT frame. The blue LED pulses on the client radio when the client successfully receives a HEARTBEAT frame from the server.</li> <li>The yellow LED pulses each time a channel hop (frequency change) occurs.</li> </ul>"},{"location":"led_states/#led-mode-leds_radio_use","title":"LED Mode - LEDS_RADIO_USE","text":"<p>This mode gives the user insight into when a bad or duplicate frame is detected. The mode number is 3.</p> <pre><code>+++\nAT-SelectLedUse=3\nATO\n</code></pre> <ul> <li>The G4 LED pulses when the radio transmits a frame.</li> <li>The G3 LED is pulse width modulated to indicate the last received RSSI level.</li> <li>The G2 LED turns on when the link is up (data can pass).</li> <li>The G1 LED pulses when the radio successfully receives a frame.</li> <li>The blue LED will blink when the radio receives a bad frame.</li> <li>The yellow LED will blink when the radio receives a duplicate frame or receives a frame where the software CRC does not match.</li> </ul>"},{"location":"operating_modes/","title":"Operating Modes","text":"<p>LoRaSerial radios can operate in one of two modes.</p> <ul> <li>Point to Point - Operating mode 1 (see AT-OperatingMode).</li> <li>Multipoint - Operating mode 0.</li> </ul>"},{"location":"operating_modes/#point-to-point","title":"Point to Point","text":"<p>By default, radios use Point to Point mode for communication. In this mode, data is limited to two paired radios.</p> <p>Radio Linkup is performed at Channel 0: Both radios power on and begin pinging each other until another radio is detected. Once a handshake is complete, both radios begin hopping through their channel tables.</p> <p>All data packets are acknowledged, guaranteeing that data will get across the link. If data is not able to traverse the link for 3 * Heartbeat Timeout (5 seconds by default) the link is marked as down and any data in the buffer is flushed. Radio Linkup is then initiated.</p> <p>Benefits of P2P:</p> <ul> <li>Data is sent until it is successfully received.</li> <li>Simple to set up and use.</li> </ul> <p>Disadvantages of P2P:</p> <ul> <li>Limited to data being shared between two radios.</li> <li>Lots of data being sent across a spotty link can lead to the link going down.</li> <li>Retransmits will add to latency.</li> </ul>"},{"location":"operating_modes/#multipoint","title":"Multipoint","text":"<p>In Multipoint mode, data is sent out from one radio to all radios. Data is not acknowledged, and therefore is not guaranteed to be delivered.</p> <p>One radio must be designated as Server. This radio is responsible for sending out heartbeat packets that synchronize the system.</p> <p>Radio Linkup is performed during a discovery phase: The Server radio immediately begins hopping the channel table. When a Client radio is powered on, it will begin traversing the channel table, sending out pings. If no response is found, the Client radio will return to channel 0. The Server radio always transmits a heartbeat on channel 0. Once a heartbeat is detected, the Client radio begins hopping through its channel tables in sync with the Server.</p> <p>Benefits of Multipoint:</p> <ul> <li>Similar to P2P, simple to set up and use. Whatever serial comes in gets broadcast.</li> <li>Supports up to 32 radios. Data can be broadcast/shared between multiple receivers. This is helpful in setups such as GNSS RTK where a Base receiver broadcasts correction data to multiple Rovers simultaneously.</li> <li>A larger continuous data stream can be transmitted. This assumes the user's application layer can handle lost packets graciously.</li> <li>This mode is most friendly to very long distance transmissions where an ACK may not be possible.</li> </ul> <p>Disadvantages of Multipoint:</p> <ul> <li>Data is not retransmitted if lost.</li> <li>Additional setup requirements: One radio must be configured as Server.</li> </ul>"},{"location":"quick_start/","title":"Quick Start Guide","text":"<p>LoRaSerial radios are very easy to use and ship ready to connect out of the box. Simply attach the antennas, plug two units into USB ports, open a terminal at each of the USB serial ports, and start passing data back and forth.</p> <p></p> <p>Passing simple text data between two radios</p> <p>The default settings are as follows:</p> <ul> <li>Mode: Point to Point</li> <li>Frequency: 902 to 928 MHz</li> <li>Channels: 50</li> <li>Frequency Hopping: Enabled</li> <li>Broadcast Power: 30 dbm</li> <li>Airspeed: 4800 bps</li> <li>Serial: 57600 bps</li> <li>Encryption: Enabled</li> <li>Encryption Key: Default<sup>1</sup></li> <li>Software CRC: Enabled</li> </ul> <p><sup>1</sup> The radios default to a published encryption key. For maximum security, we recommend changing the key and network ID value using command mode or the training process.</p> <p>Serial can be passed into the unit either through the USB port, or over the serial connector. If the serial connector is used, the baud rate is 57600 bps by default.</p> <p>LoRaSerial is designed to get small amounts of data from point A to point B as easily as possible. If you've got a sensor, or Arduino, or any device that can output serial, then it can transmit data over long distances. LoRaSerial has been used to send data over 9 miles (14 km) line-of-sight.</p>"},{"location":"quick_start/#additional-documentation","title":"Additional Documentation","text":"<p>The LoRaSerial products are described in the introduction. The radios support several operating modes.</p> <ul> <li>Point-to-Point with guaranteed delivery or the link breaks</li> <li>Multipoint, two or more LoRaSerial radios, is best for real-time applications but uses broadcast datagrams that may be lost</li> </ul> <p>Enter command mode to change modes and adjust the parameters for that mode of operation. Training is the process to distribute the set of parameters from a server radio (server=1) to the other client radios (server=0). Training can be done one radio at a time or multiple radios at once.</p> <p>The green LEDs by default display a received signal strength indication. The more LEDs that are on the better the signal. However other LED patterns are available to provide more data on the radio behavior.</p> <p>Occasionally, SparkFun may release new firmware for LoRaSerial. The firmware update procedure enables you to load the firmware into the LoRaSerial radio. Advanced users may also want to build the open source LoRaSerial firmware.</p>"},{"location":"quick_start/#hardware-documentation","title":"Hardware Documentation","text":"<p>The following hardware documents are available:</p> <ul> <li>Schematic</li> <li>Eagle Files</li> <li>Semtech SX1276 datasheet</li> <li>Ebyte E19-915M30S Datasheet</li> <li>Atmel SAMD-21 datasheet</li> <li>Understanding LoRa PHY - A good article on the math behind Semtec's Long Range modulation technique</li> </ul>"},{"location":"readme/","title":"Readme","text":"<p>This folder contains the markdown files for the LoRaSerial documents that are rendered by mkdocs.</p>"},{"location":"training/","title":"Training","text":"<p>Training is the process of passing a radio's set of parameters to other radios so that they can successfully communicate.</p> <p></p> <p>The train button on the LoRaSerial</p> <p>There are two ways to initiate training:</p> <ul> <li>Pressing the Train button on the end of the LoRaSerial device</li> <li>Entering the ATT command</li> </ul> <p>Training is performed by a server radio sending parameters to the client radio. Upon reception, the client radio saves the parameters in non-volatile memory and then reboots with the new parameters.</p> <p>Pressing and releasing the training button for different lengths of time initiates the following behaviors.</p> <p>A ball-point pen is best for pressing the training button. Be gentle. The training button can be damaged with too much force.</p>"},{"location":"training/#training-as-client","title":"Training as Client","text":"<p>Press and hold the training button until the yellow LED starts to blink then release the button. The cylon pattern appears on the green LEDs. The device is now ready to receive settings from a Server. Once settings are received from a server, the device saves the parameters to NVM and then reboots with the new settings.</p> <p>If training needs to be canceled, press and release the training button before the yellow LED starts to blink to exit training mode. No settings will be modified. The radio will return to normal operation.</p>"},{"location":"training/#training-as-server","title":"Training as Server","text":"<p>Press and hold the training button until the blue LED starts to blink then release the button. The Cylon pattern appears on the green LEDs. In this mode, the radio will respond to any training client with its settings. The radio will not exit this mode unless it is powered cycled or the ATZ reset command is issued.</p> <p>This mode (Training as Server) is convenient when multiple clients need to be paired to a server. For example, when a device is configured to be a Server in Multipoint mode, putting it in Training as Server mode will allow a user to put another radio into Training as Client. The radios will communicate and the Server radio will configure the client radio. Any number of client radios can be quickly and conveniently configured this way.</p>"},{"location":"training/#simple-point-to-point-training","title":"Simple Point-To-Point Training","text":"<p>If a radio is set for P2P mode, entering training mode as a server will generate a new random NetID and AES key. In other words, pushing the Train button and releasing it after the blue LED flashes on one radio will cause that radio to generate new, unique/secure P2P settings. On the other radio, press the Train button and release it after the yellow LED flashes. The radios will be trained to the new AES key and NetID, and the radios will reset, then immediately link up. This is helpful in the field if you need to put a pair of radios onto a different network and encryption key from other radios that may be nearby.</p>"},{"location":"training/#factory-reset","title":"Factory Reset","text":"<p>Press and hold the training button for 10 seconds to Factory Reset the radio. Release the button when all the LEDs blink quickly three times during the reset.  Just before reset the NVM is erased and LoRaSerial returns to factory settings. Note: You can also return a radio to factory defaults using the ATF command.</p>"},{"location":"training/#temporary-training-server","title":"Temporary Training Server","text":"<p>It is possible to use a temporary training server for multipoint mode. The only difference between a temporary server and a regular server is that the parameters are not saved to the non-volatile storage of the server using the ATW command before exiting command mode.</p>"},{"location":"training/#example-training-a-batch-of-radios","title":"Example: Training a Batch of Radios","text":"<p>To get a known set of parameters onto a network of radios, choose one radio to be the server. Enter command mode on the chosen server radio and set the radio's parameters as desired. Once complete, save the settings to NVM (ATW command) then enter training mode (ATT). From here, you may either use the Training buttons on the Client radios or you may use AT commands. Here is the same scenario in step-by-step instructions:</p> <p>Server:</p> <ul> <li>Enter command mode with +++</li> <li>Optionally, start from factory defaults with ATF</li> <li>Set the desired parameters</li> <li>Set AT-Server=1</li> <li>Record settings with ATW</li> <li>Enter training mode with ATT</li> <li>Have other radios enter into Training as Client mode</li> <li>Power cycle Server radio when clients are trained</li> </ul> <p>Clients can enter training via the ATT command:</p> <ul> <li>Enter command mode with +++</li> <li>Enter training mode with ATT</li> <li>The client will now obtain settings from the Server</li> <li>Settings saved to NVM</li> <li>Radio reboots</li> </ul> <p>Alternatively, the Client can enter training via the button:</p> <ul> <li>Press the training button and release it when the yellow LED</li> <li>The client will now obtain settings from the Server</li> <li>Settings saved to NVM</li> <li>Radio reboots</li> </ul>"},{"location":"training/#command-scripts","title":"Command Scripts","text":"<p>A command script is simply a text file containing the AT commands the user would like to program. For example, the following script will enter command mode, reset the device to defaults, set the radio to be Server, record settings to NVM, and then exit command mode.</p> <pre><code>+++\nATF\nAT-Server=1\nATW\nATO\n</code></pre> <p>Copying and pasting command scripts into a terminal program is an efficient way of configuring a radio.</p>"},{"location":"training/#training-parameters","title":"Training Parameters","text":"<p>The training parameters for radio communication fall into two groups:</p> <ul> <li>Radio parameters</li> <li>Radio protocol parameters</li> </ul> <p>Other optional sets of training parameters may be communicated between the radios when the corresponding copyXxxx parameter is set to true (1). The optional parameter sets are:</p> <ul> <li>Serial parameters</li> <li>Debug parameters</li> <li>Trigger parameters</li> </ul> <p>For more information about the various radio settings, please see AT Commands.</p>"},{"location":"training/#security-considerations","title":"Security Considerations","text":"<p>Summary: We recommend training radios located next to each other, in a secure area with antennas removed, to limit the amount of RF emissions and potential security issues. If security is a great concern, do not use training. Instead, AT commands can be used to set the settings between radios including AES keys.</p> <p>During training, the Server will broadcast sensitive information including AES keys. Additionally, all radios used in training will use the default, published training settings. These include the following important parameters:</p> <ul> <li>14dBm lower power transmission</li> <li>Default training frequency and hop tables</li> <li>Default training AES key</li> </ul> <p>By default, radios will use the lowest power transmission possible of 14dBm. This is to limit RF eavesdropping. While data is encrypted and frequency hopping is used, the key is publicly published, and the hop table could be deduced. In theory, the transmitted parameters, including link keys that are trained to the Client could be obtained. </p> <p>If desired, the AES key used during training can be assigned to all units either using training (note the security issue) or via AT commands. This allows future training to be secure.</p>"}]}